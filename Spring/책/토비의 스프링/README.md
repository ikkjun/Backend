# 토비의 스프링
## 핵심
1. IoC / DI
2. 서비스 추상화
3. AOP

## Vol. 1 스프링의 이해와 원리
### 1장 오브젝트와 의존관계
#### 1.1 초난감 DAO
##### 1.1.1 User
##### 1.1.2 UserDao
##### 1.1.3 main()을 이용한 DAO 테스트 코드

#### 1.2 DAO의 분리
##### 1.2.1 관심사의 분리
##### 1.2.2 커넥션 만들기의 추출
##### 1.2.3 DB 커넥션 만들기의 독립

#### 1.3 DAO의 확장
##### 1.3.1 클래스의 분리
##### 1.3.2 인터페이스의 도입
##### 1.3.3 관계 설정 책임의 분리
##### 1.3.4 원칙과 패턴

#### 1.4 제어의 역전(IoC)
##### 1.4.1 오브젝트 팩토리
##### 1.4.2 오브젝트 팩토리의 활용
##### 1.4.3 제어권의 이전을 통한 제어관계 역전

#### 1.5 스프링의 IoC
##### 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC
##### 1.5.2 애플리케이션 컨텍스트의 동작방식
##### 1.5.3 스프링 IoC의 용어 정리

#### 1.6 싱글톤 레지스트리와 오브젝트 스코프
##### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
##### 1.6.2 싱글톤과 오브젝트의 상태
##### 1.6.3 스프링 빈의 스코프

#### 1.7 의존관계 주입(DI)
##### 1.7.1 제어의 역전(IoC)과 의존관계 주입
##### 1.7.2 런타임 의존관계 설정
##### 1.7.3 의존관계 검색과 주입
##### 1.7.4 의존관계 주입의 응용
##### 1.7.5 메소드를 이용한 의존관계 주입

#### 1.8 XML을 이용한 설정
##### 1.8.1 XML 설정
##### 1.8.2 XML을 이용하는 애플리케이션 컨텍스트
##### 1.8.3 DataSource 인터페이스로 변환
##### 1.8.4 프로퍼티 값의 주입

#### 1.9 정리

### 2장 테스트
#### 2.1 초난감 DAO
##### 2.1.1 테스트의 유용성
##### 2.1.2 UserDaoTest의 특징
##### 2.1.3 UserDaoTest의 문제점

#### 2.2 USERDAOTEST 개선
##### 2.2.1 테스트 검증의 자동화
##### 2.2.2 테스트의 효율적인 수행과 결과 관리

#### 2.3 개발자를 위한 테스팅 프레임워크 JUNIT
##### 2.3.1 JUnit 테스트 실행 방법
##### 2.3.2 테스트 결과의 일관성
##### 2.3.3 포괄적인 테스트
##### 2.3.4 테스트가 이끄는 개발
##### 2.3.5 테스트 코드 개선

#### 2.4 스프링 테스트 적용
##### 2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리
##### 2.4.2 DI와 테스트

#### 2.5 학습 테스트로 배우는 스프링
##### 2.5.1 학습 테스트의 장점
##### 2.5.2 학습 테스트 예제
##### 2.5.3 버그 테스트

### 3장 템플릿
 #### 3.1 다시보는 초난감 DAO
##### 3.1.1 예외처리 기능을 갖춘 DAO

 #### 3.2 변하는 것과 변하지 않는 것
##### 3.2.1 JDBC try / catch / finally 코드의 문제점
##### 3.2.2 분리와 재사용을 위한 디자인 패턴 적용

 #### 3.3 JDBC 전략 패턴의 최적화
##### 3.3.1 전략 클래스의 추가 정보
##### 3.3.2 전략과 클라이언트의 동거

 #### 3.4   컨텍스트와 DI
##### 3.4.1 JdbcContext의 분리
##### 3.4.2 JdbcContext의 특별한 DI

 #### 3.5   템플릿과 콜백
##### 3.5.1 템플릿/콜백의 동작원리
##### 3.5.2 편리한 콜백의 재활용
##### 3.5.3 템플릿/콜백의 응용

 #### 3.6   스프링의 JDBCTEMPLATE
##### 3.6.1 update()
##### 3.6.2 queryForInt()
##### 3.6.3 queryForObject()
##### 3.6.4 query()
##### 3.6.5 재사용 가능한 콜백의 분리

 #### 3.7   정리


### 4장 예외
 #### 4.1 사라진 SQLEXCEPTION
##### 4.1.1 초난감 예외처리
##### 4.1.2 예외의 종류와 특징
##### 4.1.3 예외 처리 방법
##### 4.1.4 예외처리 전략
##### 4.1.5 SQLException은 어떻게 됐나?
      
 #### 4.2 예외 전환
##### 4.2.1 JDBC의 한계
##### 4.2.2 DB 에러 코드 매핑을 통한 전환
##### 4.2.3 DAO 인터페이스와 DataAccessException 계층구조
##### 4.2.4 기술에 독립적인 UserDao 만들기

 #### 4.3 정리

### 5장 서비스 추상화
 #### 5.1   사용자 레벨 관리 기능 추가
##### 5.1.1 필드 추가
##### 5.1.2 사용자 수정 기능 추가
##### 5.1.3 UserService.upgradeLevels()
##### 5.1.4 UserService.add()
##### 5.1.5 코드 개선

 #### 5.2   트랜잭션 서비스 추상화
##### 5.2.1 모 아니면 도
##### 5.2.2 트랜잭션 경계 설정
##### 5.2.3 트랜잭션 동기화
##### 5.2.4 트랜잭션 서비스 추상화

 #### 5.3   서비스 추상화와 단일 책임 원칙

 #### 5.4   메일 서비스 추상화
##### 5.4.1 JavaMail을 이용한 메일 발송 기능
##### 5.4.2 JavaMail이 포함된 코드의 테스트
##### 5.4.3 테스트를 위한 서비스 추상화
##### 5.4.4 테스트 대역

 #### 5.5   정리

### 6장 AOP
 #### 6.1   트랜잭션 코드의 분리
##### 6.1.1 메소드 분리
##### 6.1.2 DI를 이용한 클래스의 분리

 #### 6.2   고립된 단위 테스트
##### 6.2.1 복잡한 의존관계 속의 테스트
##### 6.2.2 테스트 대상 오브젝트 고립시키기
##### 6.2.3 단위 테스트와 통합 테스트
##### 6.2.4 목 프레임워크

 #### 6.3   다이내믹 프록시와 팩토리 빈
##### 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴
##### 6.3.2 다이내믹 프록시
##### 6.3.3 다이내믹 프록시를 이용한 트랜잭션 부가기능
##### 6.3.4 다이내믹 프록시를 위한 팩토리 빈
##### 6.3.5 프록시 팩토리 빈 방식의 장점과 한계

 #### 6.4   스프링의 프록시 팩토리 빈
##### 6.4.1 ProxyFactoryBean
##### 6.4.2 ProxyFactoryBean 적용

 #### 6.5   스프링 AOP
##### 6.5.1 자동 프록시 생성
##### 6.5.2 DefaultAdvisorAutoProxyCreator의 적용
##### 6.5.3 포인트컷 표현식을 이용한 포인트 컷
##### 6.5.4 AOP란 무엇인가?
##### 6.5.5 AOP 적용 기술
##### 6.5.6 AOP의 용어
##### 6.5.7 AOP 네임스페이스

 #### 6.6   트랜잭션 속성
##### 6.6.1 트랜잭션 정의
##### 6.6.2 트랜잭선 인터셉터와 트랜잭션 속성
##### 6.6.3 포인트컷과 트랜잭션 속성의 적용 전략
##### 6.6.4 트랜잭션 속성 적용

 #### 6.7   애노테이션 트랜잭션 속성과 포인트 컷
##### 6.7.1 트랜잭션 애노테이션
##### 6.7.2 트랜잭션 애노테이션 적용

 #### 6.8   트랜잭션 지원 테스트
##### 6.8.1 선언적 트랜잭션과 트랜잭션 전파 속성
##### 6.8.2 트랜잭션 동기화 테스트
##### 6.8.3 테스트를 위한 트랜잭션 애노테이션
      
 #### 6.9   정리

### 7장 스프링 핵심 기술의 응용
 #### 7.1   SQL과 DAO의 분리
##### 7.1.1 XML 설정을 이용한 분리
##### 7.1.2 SQL 제공 서비스

 #### 7.2   인터페이스의 분리와 자기참조 빈
##### 7.2.1 XML 파일 매핑
##### 7.2.2 XML 파일을 이용하는 SQL 서비스
##### 7.2.3 빈의 초기화 작업
##### 7.2.4 변화를 위한 준비: 인터페이스 분리
##### 7.2.5 자기참조 빈으로 시작하기
##### 7.2.6 디폴트 의존관계

 #### 7.3   서비스 추상화 적용
##### 7.3.1 OXM 서비스 추상화
##### 7.3.2 OXM 서비스 추상화 적용
##### 7.3.3 리소스 추상화

 #### 7.4   인터페이스 상속을 통한 안전한 기능 확장
##### 7.4.1 DI와 기능의 확장
##### 7.4.2 인터페이스 상속

 #### 7.5   DI를 이용해 다양한 구현 방법 적용하기
##### 7.5.1 ConcurrentHashMap을 이용한 수정 기능
##### 7.5.2 내장형 데이터베이스를 이용한 SQL 레지스트리 만들기
##### 7.5.3 트랜잭션 적용

 #### 7.6   스프링 3.1의 DI
##### 7.6.1 자바 코드를 이용한 빈 설정
##### 7.6.2 빈 스캐닝과 자동와이어링
##### 7.6.3 컨텍스트 분리와 @Import
##### 7.6.4 프로파일
##### 7.6.5 프로퍼티 소스
##### 7.6.6 빈 설정의 재사용과 @Enable*
      
 #### 7.7   정리

### 8장 스프링이란 무엇인가?
 #### 8.1   스프링의 정의
      
 #### 8.2   스프링의 목적
##### 8.2.1 엔터프라이즈 개발의 복잡함
##### 8.2.2 복잡함을 해결하려는 도전
##### 8.2.3 복잡함을 상대하는 스프링의 전략

 #### 8.3   POJO 프로그래밍
##### 8.3.1 스프링의 핵심: POJO
##### 8.3.2 POJO란 무엇인가?
##### 8.3.3 POJO의 조건
##### 8.3.4 POJO의 장점
##### 8.3.5 POJO 프레임워크

 #### 8.4   스프링의 기술
##### 8.4.1 제어의 역전(IoC) / 의존관계 주입(DI)
##### 8.4.2 애스펙트 지향 프로그래밍(AOP)
##### 8.4.3 포터블 서비스 추상화(PSA)
      
 #### 8.5   정리

### 9장 스프링 프로젝트 시작하기
 #### 9.1   자바 엔터프라이즈 플랫폼과 스프링 애플리케이션
##### 9.1.1 클라이언트와 백엔드 시스템
##### 9.1.2 애플리케이션 서버
##### 9.1.3 스프링 애플리케이션의 배포 단위

 #### 9.2   개발도구와 환경
##### 9.2.1 JavaSE와 JavaEE
##### 9.2.2 IDE
##### 9.2.3 SpringSource Tool Suite
##### 9.2.4 라이브러리 관리와 빌드 툴

 #### 9.3   애플리케이션 아키텍처
##### 9.3.1 계층형 아키텍처
##### 9.3.2 애플리케이션 정보 아키텍처
##### 9.3.3 오브젝트 중심 아키텍처
##### 9.3.4 스프링 애플리케이션을 위한 아키텍처 설계
      
 #### 9.4   정리

## Vol. 2 스프링의 기술과 선택
### 1장 IoC 컨테이너와 DI
### 2장 데이터 액세스 기술
### 3장 스프링 웹 기술과 스프링 MVC
### 4장 스프링 @MVC
### 5장 AOP와 LTW
### 6장 테스트 컨텍스트 프레임워크
### 7장 스프링의 기타 기술과 효과적인 학습 방법