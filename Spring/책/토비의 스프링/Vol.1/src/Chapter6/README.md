# 6장 AOP
## 6.1   트랜잭션 코드의 분리
### 6.1.1 메소드 분리
### 6.1.2 DI를 이용한 클래스의 분리

비즈니스 로직을 담은 서비스 클래스에서 트랜잭션 경계설정 코드를 분리한 클래스를 새로 정의해야 한다.
그리고 트랜잭션이 정의된 클래스에 DI를 통해 서비스 클래스를 주입해야 한다.
이를 통해 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션을 고려하지 않아도 된다.
그리고 비즈니스 로직에 대한 테스트를 쉽게 만들 수 있다.

## 6.2   고립된 단위 테스트
### 6.2.1 복잡한 의존관계 속의 테스트
### 6.2.2 테스트 대상 오브젝트 고립시키기
### 6.2.3 단위 테스트와 통합 테스트
### 6.2.4 목 프레임워크

## 6.3   다이내믹 프록시와 팩토리 빈
### 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴
### 6.3.2 다이내믹 프록시
### 6.3.3 다이내믹 프록시를 이용한 트랜잭션 부가기능
### 6.3.4 다이내믹 프록시를 위한 팩토리 빈
### 6.3.5 프록시 팩토리 빈 방식의 장점과 한계

## 6.4   스프링의 프록시 팩토리 빈
### 6.4.1 ProxyFactoryBean
### 6.4.2 ProxyFactoryBean 적용

## 6.5   스프링 AOP
### 6.5.1 자동 프록시 생성
### 6.5.2 DefaultAdvisorAutoProxyCreator의 적용
### 6.5.3 포인트컷 표현식을 이용한 포인트 컷
### 6.5.4 AOP란 무엇인가?
### 6.5.5 AOP 적용 기술
### 6.5.6 AOP의 용어
### 6.5.7 AOP 네임스페이스

## 6.6   트랜잭션 속성
### 6.6.1 트랜잭션 정의
### 6.6.2 트랜잭선 인터셉터와 트랜잭션 속성
### 6.6.3 포인트컷과 트랜잭션 속성의 적용 전략
### 6.6.4 트랜잭션 속성 적용

## 6.7   애노테이션 트랜잭션 속성과 포인트 컷
### 6.7.1 트랜잭션 애노테이션
### 6.7.2 트랜잭션 애노테이션 적용

## 6.8   트랜잭션 지원 테스트
### 6.8.1 선언적 트랜잭션과 트랜잭션 전파 속성
### 6.8.2 트랜잭션 동기화 테스트
### 6.8.3 테스트를 위한 트랜잭션 애노테이션

## 6.9   정리