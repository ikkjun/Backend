# 6장 AOP
## 6.1   트랜잭션 코드의 분리
### 6.1.1 메소드 분리
### 6.1.2 DI를 이용한 클래스의 분리

비즈니스 로직을 담은 서비스 클래스에서 트랜잭션 경계설정 코드를 분리한 클래스를 새로 정의해야 한다.
그리고 트랜잭션이 정의된 클래스에 DI를 통해 서비스 클래스를 주입해야 한다.
이를 통해 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션을 고려하지 않아도 된다.
그리고 비즈니스 로직에 대한 테스트를 쉽게 만들 수 있다.

## 6.2   고립된 단위 테스트
### 6.2.1 복잡한 의존관계 속의 테스트
### 6.2.2 테스트 대상 오브젝트 고립시키기
### 6.2.3 단위 테스트와 통합 테스트
### 6.2.4 목 프레임워크

단위 테스트는 가능한 한 작은 단위로 진행해야 한다. 
그러나 테스트의 대상이 다른 오브젝트와 환경에 의존하고 있다면 테스트를 위한 대역을 사용해서 테스트 대상 오브젝트를 분리한 뒤, 고립시켜야 한다.

단위 테스트를 만들기 위해 스텁이나 목 오브젝트를 반드시 사용해야 한다. 
목 오브젝트를 간편하게 만들 수 있는 Mockito 프레임워크를 사용하면 테스트를 할 때마다 목 오브젝트를 만들어야 하는 번거로움을 줄일 수 있다.

## 6.3   다이내믹 프록시와 팩토리 빈
### 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴
### 6.3.2 다이내믹 프록시
### 6.3.3 다이내믹 프록시를 이용한 트랜잭션 부가기능
### 6.3.4 다이내믹 프록시를 위한 팩토리 빈
### 6.3.5 프록시 팩토리 빈 방식의 장점과 한계

다이내믹 프록시는 런타임 때 프록시 패턴에 의해 다이내믹하게 만들어지는 오브젝트이다.
트랜젝션 부가기능을 제공하는 다이내믹 프록시를 사용하는 것이 효율적이다.
다이내믹 프록시는 Proxy 클래스의 newProxyInstance()라는 스태틱 팩토리 메서드를 통해서만 생성할 수 있다. 
그러므로 FactoryBean 인터페이스를 구현한 팩토리 빈을 통해 빈을 생성해야 한다.
다이내믹 프록시를 생성하는 팩토리 빈을 재사용하면 프록시 클래스를 계속 만들 필요가 없고, 코드의 중복 문제를 해결할 수 있다.

그러나 한 번에 여러 개의 클래스에 공통적인 부가기능을 적용하지 못한다는 한계가 있다.
그리고 TransactionHandler 오브젝트가 프록시 팩토리 빈 개수 만큼 만들어진다는 한계가 있다.

## 6.4   스프링의 프록시 팩토리 빈
### 6.4.1 ProxyFactoryBean
### 6.4.2 ProxyFactoryBean 적용

트랜잭션 부가기능을 추가하기 위해 프록시를 생성해서 빈 오브젝트로 등록해주는 ProxyFactoryBean을 사용해야 한다.
ProxyFactoryBean은 부가기능을 제공하는 오브젝트인 어드바이스와 메서드 선정 알고리즘을 담은 포인트 컷을 활용하여 유용한 구조를 제공한다.
어드바이스와 포인트 컷은 여러 개가 추가될 수 있으므로 별개의 오브젝트로 묶어서 등록해야 한다.
이처럼 어드바이스와 포인트 컷을 묶은 오브젝트를 어드바이저라고 부른다.

## 6.5   스프링 AOP
### 6.5.1 자동 프록시 생성
### 6.5.2 DefaultAdvisorAutoProxyCreator의 적용
### 6.5.3 포인트컷 표현식을 이용한 포인트 컷
### 6.5.4 AOP란 무엇인가?
### 6.5.5 AOP 적용 기술
### 6.5.6 AOP의 용어
### 6.5.7 AOP 네임스페이스

ProxyFactoryBean 빈 설정정보가 중복되는 문제를 해결하기 위해 DefaultAdvisorAutoProxyCreator 빈 후처리기를 활용해야 한다.
DefaultAdvisorAutoProxyCreator는 어드바이저를 이용한 자동 프록시 생성기이다.
DefaultAdvisorAutoProxyCreator는 클래스와 메서드 선정 알고리즘을 모두 갖고 있는 포인트 컷과 어드바이스가 결합되어 있는 어드바이저가 등록되어 있어야 한다.
포인트 컷의 클래스와 메서드를 선정하는 알고리즘은 포인트 컷 표현식으로 간편하게 작성할 수 있다. 

어드바이저를 통해 핵심기능에 부여되는 부가기능을 효과적으로 모듈화할 수 있게 되었다.
애스펙트는 핵심기능에 부가적인 의미를 갖는 특별한 모듈을 의미한다.
애스펙트라는 독특한 모듈을 만들어서 설계하고 개발하는 방법을 애스켁트 지향 프로그래밍(Aspect Oriented Programming; AOP)이라고 한다.
AOP는 애스펙트를 분리함으로써 핵심기능을 설계하고 구현할 때 객체지향적인 설계를 돕는다.
이때 애스펙트를 다양한 타깃 오브젝트의 메소드에 다이내믹하게 적용하기 위해 프록지사 AOP에서 가장 중요한 역할을 맡고 있다. 
그러나 AOP는 프록시를 사용하지 않더라도 바이트 코드를 조작해서 직접적으로 부가기능을 넣어줄 수 있다. 

## 6.6   트랜잭션 속성
### 6.6.1 트랜잭션 정의
### 6.6.2 트랜잭선 인터셉터와 트랜잭션 속성
### 6.6.3 포인트컷과 트랜잭션 속성의 적용 전략
### 6.6.4 트랜잭션 속성 적용
트랜잭션이란 더 이상 쪼갤 수 없는 최소 단위의 작업이다.
트랜잭션의 동작 방식에 영항을 줄 수 있는 속성으로 트랜잭션 전파(transaction propagation), 격리수준(isolation level), 제한시간(timeout), 읽기 전용(read-only)이 있다. 

## 6.7   애노테이션 트랜잭션 속성과 포인트 컷
### 6.7.1 트랜잭션 애노테이션
### 6.7.2 트랜잭션 애노테이션 적용

세밀한 트랜잭션 속성의 제어가 필요한 경우에 트랜잭션 애노테이션(@Transactional)을 사용하면 된다.
그러나 메서드마다 @Transactional을 부여하면 코드가 지저분하고, 바람직하지 못한 결과를 가져올 수 있다.
이때 4단계의 대체(fallback) 정책인 타깃 메서드, 타깃 클래스, 선언 메서드, 선언 타입(클래스, 인터페이스)에 따라 순서대로 @Transactional이 적용됐는지 확인해서 가장 먼저 발견되는 속성 정보를 사용한다.

## 6.8   트랜잭션 지원 테스트
### 6.8.1 선언적 트랜잭션과 트랜잭션 전파 속성
### 6.8.2 트랜잭션 동기화 테스트
### 6.8.3 테스트를 위한 트랜잭션 애노테이션

트랜잭션의 전파 속성을 지정해주는 두 가지 방식이 있다. 
선언적 트랜잭션(declarative transaction)이란 AOP를 이용해 코드 외부에서 트랜잭션의 기능을 부여하고 속성을 지정하는 방법이다.
프로그램에 의한 트랜잭션(programmatic transaction)이란 Transaction Template이나 개별 데이터 기술의 트랜잭션 API를 사용해 직접 코드 안에서 사용하는 방법이다.

스프링의 트랜잭션 추상화 기술과 AOP로 트랜잭션의 자유로운 전파가 가능하다. 
트랜잭션 추상화의 핵심 기술은 트랜잭션 매니저와 트랜잭션 동기화이다.
트랜잭션의 전파는 트랜잭션 매니저를 통해 트랜잭션 동기화 방식이 적용되기 때문에 가능하다.

테스트에서 트랜잭션을 제어하면서 롤백 테스트를 적절하게 활용할 수 있게 되었다.
롤백 테스트는 테스트를 진행하는 동안에 조작한 데이터를 모두 롤백하고 테스트를 시작하기 전 상태로 만들어 준다.
테스트를 위한 애너테이션으로 @Transactional, @Rollback, @TransactionConfiguration이 있다.

## 6.9   정리
AOP를 이용해 트랜잭션 속성을 지정하는 방법
1. 포인트 컷 표현식
2. 메소드 이름 패턴
3. @Transactional 애노테이션