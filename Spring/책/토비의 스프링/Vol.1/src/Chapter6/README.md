# 6장 AOP
## 6.1   트랜잭션 코드의 분리
### 6.1.1 메소드 분리
### 6.1.2 DI를 이용한 클래스의 분리

비즈니스 로직을 담은 서비스 클래스에서 트랜잭션 경계설정 코드를 분리한 클래스를 새로 정의해야 한다.
그리고 트랜잭션이 정의된 클래스에 DI를 통해 서비스 클래스를 주입해야 한다.
이를 통해 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션을 고려하지 않아도 된다.
그리고 비즈니스 로직에 대한 테스트를 쉽게 만들 수 있다.

## 6.2   고립된 단위 테스트
### 6.2.1 복잡한 의존관계 속의 테스트
### 6.2.2 테스트 대상 오브젝트 고립시키기
### 6.2.3 단위 테스트와 통합 테스트
### 6.2.4 목 프레임워크

단위 테스트는 가능한 한 작은 단위로 진행해야 한다. 
그러나 테스트의 대상이 다른 오브젝트와 환경에 의존하고 있다면 테스트를 위한 대역을 사용해서 테스트 대상 오브젝트를 분리한 뒤, 고립시켜야 한다.

단위 테스트를 만들기 위해 스텁이나 목 오브젝트를 반드시 사용해야 한다. 
목 오브젝트를 간편하게 만들 수 있는 Mockito 프레임워크를 사용하면 테스트를 할 때마다 목 오브젝트를 만들어야 하는 번거로움을 줄일 수 있다.

## 6.3   다이내믹 프록시와 팩토리 빈
### 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴
### 6.3.2 다이내믹 프록시
### 6.3.3 다이내믹 프록시를 이용한 트랜잭션 부가기능
### 6.3.4 다이내믹 프록시를 위한 팩토리 빈
### 6.3.5 프록시 팩토리 빈 방식의 장점과 한계

다이내믹 프록시는 런타임 때 프록시 패턴에 의해 다이내믹하게 만들어지는 오브젝트이다.
트랜젝션 부가기능을 제공하는 다이내믹 프록시를 사용하는 것이 효율적이다.
다이내믹 프록시는 Proxy 클래스의 newProxyInstance()라는 스태틱 팩토리 메서드를 통해서만 생성할 수 있다. 
그러므로 FactoryBean 인터페이스를 구현한 팩토리 빈을 통해 빈을 생성해야 한다.
다이내믹 프록시를 생성하는 팩토리 빈을 재사용하면 프록시 클래스를 계속 만들 필요가 없고, 코드의 중복 문제를 해결할 수 있다.

그러나 한 번에 여러 개의 클래스에 공통적인 부가기능을 적용하지 못한다는 한계가 있다.
그리고 TransactionHandler 오브젝트가 프록시 팩토리 빈 개수 만큼 만들어진다는 한계가 있다.

## 6.4   스프링의 프록시 팩토리 빈
### 6.4.1 ProxyFactoryBean
### 6.4.2 ProxyFactoryBean 적용

## 6.5   스프링 AOP
### 6.5.1 자동 프록시 생성
### 6.5.2 DefaultAdvisorAutoProxyCreator의 적용
### 6.5.3 포인트컷 표현식을 이용한 포인트 컷
### 6.5.4 AOP란 무엇인가?
### 6.5.5 AOP 적용 기술
### 6.5.6 AOP의 용어
### 6.5.7 AOP 네임스페이스

## 6.6   트랜잭션 속성
### 6.6.1 트랜잭션 정의
### 6.6.2 트랜잭선 인터셉터와 트랜잭션 속성
### 6.6.3 포인트컷과 트랜잭션 속성의 적용 전략
### 6.6.4 트랜잭션 속성 적용

## 6.7   애노테이션 트랜잭션 속성과 포인트 컷
### 6.7.1 트랜잭션 애노테이션
### 6.7.2 트랜잭션 애노테이션 적용

## 6.8   트랜잭션 지원 테스트
### 6.8.1 선언적 트랜잭션과 트랜잭션 전파 속성
### 6.8.2 트랜잭션 동기화 테스트
### 6.8.3 테스트를 위한 트랜잭션 애노테이션

## 6.9   정리
